---
layout: post
title:  tora
date:	2014-11-23 07:50:18
categories: haxelib
---


Tora 是一个基于 neko 的服务器应用程序，用来作为网站后台程序。它本身并不包含 HTTP 服务器, 而使用代理的方式

 * 由 Apache 或 nginx 接收 HTTP 请求并处理

 * Apache 或 nginx 将指定的 `.n` 文件的请求发送给 Tora 程序

 * Tora程序处理之后并返送回处理结果

由于 Tora 是一个单进程多线程服务器, 可以加载任意 haxe/neko 的 web 应用. 并可以扩展提供额外的 API.


<!-- more -->


### 安装

https://github.com/jasononeil/tora-installation-helper

#### tora


 * 下载 [tora](https://github.com/HaxeFoundation/tora)

 * 双击 build.hxml 编译 tora.n 和 tora_admin.n

命令行参数:

```bash
-h	-host <host>	# 更改绑定主机, 默认为: 127.0.0.1
-p	-port <port>	# 更改绑定端口, 默认为: 6666
# 上边二项在修改后注意需要和 nginx 或 apache 的配置相匹配

-fcgi 	# 使用 fcgi 模式, 比如和 nginx 服务器

-t	-threads <num>	# 线程数量, 默认为: 32

-debugport <port>	# 指定调试端口, 默认: 无. TODO: 未知

# 下边二个选项目前仅支持 apache 服务器
-unsafe <host:port>	# 打开一个端口，允许直接连接到 Tora 服务器. 而不是通过 apache 或 nginx 的代理
					# 当直接连接到 Tora 时, 注意使用正确的 server_name + index.n， 需要 Apache
					
-config	<fiel>		# 解析一个 Apache 配置文件，寻找 VirtualHosts， 用来配合 -unsafe 参数
#<VirtualHost>
#    DocumentRoot wwwroot/some/
#    ServerName localhost
#</VirtualHost>
```

源码包中的另一个 `Admin.hx` 将被编译成 `tora_admin.n`, 这是其实是tora的网页, 当tora服务器配置正常时,在浏览中打开这个文件


#### nginx

[下载 nginx](http://nginx.org/en/download.html)

windows dos下帮助信息：

```bat
Usage: nginx [-?hvVtq] [-s signal] [-c filename] [-p prefix] [-g directives]

Options:
  -?,-h         : this help
  -v            : show version and exit
  -V            : show version and configure options then exit
  -t            : test configuration and exit
  -q            : suppress non-error messages during configuration testing
  -s signal     : send signal to a master process: stop, quit, reopen, reload
  -p prefix     : set prefix path (default: NONE)
  -c filename   : set configuration file (default: conf/nginx.conf)
  -g directives : set global directives out of configuration file

:: 仅测试,而不启动, 当你调试各种参数时先测试
nginx -t

:: 启动,使用 start 是因为 nginx 会阻塞当前CMD窗口
start nginx

:: 快速停止 nginx，可能并不保存相关信息
nginx -s stop

:: 完整有序的停止nginx，并保存相关信息
nginx -s quit

:: 关于 -p 参数用于指定 nginx 目录, 你可能需要复制整个目录除了 nginx.exe 到目标目录
```

[conf 的配置中文](http://www.cszhi.com/20120513/nginx_nginx-conf.html), 将下边代码加入到相应的位置

```conf
# 1. 复制 nginx.conf 的副本并改名为其它如 tora.conf
# 2. 将下列代码添加到相应位置

location ~ \.n$ {
  fastcgi_pass 127.0.0.1:6666;
  fastcgi_index index.n;
  fastcgi_param SCRIPT_FILENAME  $document_root$fastcgi_script_name; 
  
  fastcgi_param DOCUMENT_URI $document_uri;
  fastcgi_param REMOTE_ADDR $remote_addr;
  fastcgi_param QUERY_STRING q=$uri&$query_string;
  fastcgi_param SERVER_NAME $server_name;
  fastcgi_param REQUEST_METHOD $request_method;		
  fastcgi_param CONTENT_TYPE $content_type;
  fastcgi_param CONTENT_LENGTH $content_length;			
  fastcgi_param REMOTE_PORT $remote_port;
  fastcgi_param SERVER_ADDR $server_addr;
  fastcgi_param SERVER_PORT $server_port;
}

# $document_root 表示为根目录, 如果未设置 root 变量, 则默认值为 html
# $fastcgi_script_name 注意: 这个变量名前不要加 / 斜线
```

上边这种配置仅用于测试, 个人感觉 tora 不太适合处理太多不同名字的 `.n` 模块, 最好固定它们如: `app.n`, `templo.n`:

```conf
location /app {
  fastcgi_param SCRIPT_FILENAME $document_root/app.n;

# fastcgi_param SCRIPT_FILENAME R:/some_proj/bin/app.n;
# ...
}

location /templo {
  fastcgi_param SCRIPT_FILENAME $document_root/templo.n;
# ......
}
```

#### apache


在 haxe 的安装包的 neko 目录下可以找到:

```bash
# HaxeToolkit/neko

mod_tora.ndll	# 用于 apache 1.3

mod_tora2.dnll	# apache 2.x
```

### 文档

tora 源码包的 tora 目录下， 文档只有 http://ncannasse.fr/blog/tora_comet

#### API

全部为静态方法及静态属性:

 * `lib(default,null):String` 初使化时根据 tora.exe 设置的环境变量选择加 `mod_neko.ndll` 还是 `mod_neko2.ndll`

 * `getInfos():Infos;`

 * `command(cmd:String, ?param:String):Dynamic`; 控制 tora.exe 的一些行为, 我不太确定是否为 `Tora.hx::command()` 

	```
	# 所有命令如果有输出, 都是直接以 Sys.print 的方式, 不返回任何值
	stop		# 停止 tora	
	gc			# 
	clean		# 
	hosts		# 直接输出到 stdout, host_name => path/to/file
	share				# 输出 Share 对象的名称及占用大小
	thread(n:Int)		# 输出指定线程信息,如果存在. e.g: `Api.command("thread", "0");`
	memory(file:String)	# 解析一个 neko 文件并打印其所有 names 占用的内存大小
	```

 * `setCron(url:String, delay:Float ):Void`

 * `getExports(host: String):Dynamic;`

 * `getURL(host:String, uri:String, params:Map<String,String>):String`

#### Protocol

你可能想要绕过这个问题, 这个类能创建 Flas与Tora 的连接. 使 flash 连接到 -unsafe 指定的端口。 然后 flash 可以和 tora 模块交互获得 Share 数据.


#### Queue

消息队列. `Queue<T>`, 我并不太楚这个是用来做什么的

 * `addHandler(h : Handler<T>):Void`

 * `notify(message:T):Void`

 * `count():Int`

 * `stop():Void`

 * `static get<T>(name):Queue<T>`

思考下边描述:

 * 一个客户端连接到 web 应用程序, 应用程序发送数据的当前状态，然后调用 listen

 * 当另一个客户端对数据进行了更改, 他可以在相应的 Queue 上调用 notify,用给定的 message.

 * notify message 将被传递给所有回调, 可以选择忽略或者格式化发给客户端.

 * 当客户端断开连接, 在允许适当的通知时 onStop 将被调用

 * 对得到的 message 作出响应， 客户端可以选择停止 Queue 上的监听，这时连接将关闭

 * 可以获得监听这个 message queue 的所有客户端的数量.

主要的优点是, 所有此 API 将融入你的 web 程序, 不再需要一个单独自定义服务器. 同样, 当一个客户端监听在 Queue 上， 调用将立即返回通常情况下并退出， 然后相应的 Tora 线程是空闲的可以处理其它请求.

但是, 如果你的连接通过 mod_tora(已经略有修改处理监听),那么当一个 Apache 进程或线程将仍在使用当客户端处于监听中, 这不会占用很多资源, 但是有另一个问题,目前还没有办法检测客户端已经断开到 Apache 的连接. 你只能在当向它发送一些数据时才能知道, 但是除非你想要实时通知已经断开的客户端, 这还是非常有用.

个人理解: 由于 http 连接不是长连接,只能在用户从 apache 请求数据时将会获得 queue 的处理, 
> 通过 session 为每个客户端创建一个唯一标识符来创建 Queue。
> 但实际上 neko 或 tora 并没有相关 Session 的 API可用, 也许我们需要用 Share 来创建一个

##### Handler

Queue 的 addHandler 参数类型， 你需要重写其中的几个方法.

#### Share

在不同的模块(.n文件)中共享永久数据(直至重启tora.exe). 比用数据库共享更为高效和便捷 http://old.haxe.org/doc/neko/tora_share,

 * `new(name:String, make:Void->T)` name 为共享数据的标识符, 如果没有相应的数据,则会调用 make 来新建一个.

 * `get(lock:Bool):T` 获得相应的数据, 参数 lock 表示是否锁定,防止其它线程访问. 稍后你需要调用 `.commit()` 来释放锁

 * `set(data:T):Void` 设置数据, 如果你修改了通过 get 获得的数据, 并且想要新到共享,需要调用这个方法

 * `commit():Void`	释放 `get(true)` 的锁定

 * `free()` 删除这个 name 所对应的共享的数据，需要在获得锁的状态下调用


需要注意是， 不能保证数据的并发访问, 一个对锁定的数据进行修改的线程可能导致另一个读取没有锁定数据的线程崩溃, 这需要你来保证适当的原子性, （？？？每个对 `Share::get` 方法都传入 true 为参数）

由于数据在重启 tora 时失效, 因此在重启 tora 时, 应该先临时关闭网站的访问, 或者哪些数据并不适合用 Share 来保存.


对于 neko 目标,还有个 Web.cacheModule 的方法可以用于缓存数据, 但是这个方法不适用 tora 环境 https://github.com/HaxeFoundation/tora/issues/6 , 因为当一个模块很忙时, tora 会另开一个线程来处理.

<br />
<br />