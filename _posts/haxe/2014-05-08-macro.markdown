---

layout: post
title:	宏和条件编译
date:   2014-05-08 10:26:10
categories: haxe

---

宏 是 Haxe 最主要也是最强大的特性,最新的[官网参考](http://haxe.org/manual/macro.html)

> 在编译时通过计算初使化一些值,比如 UI 的配置等等.
>
> 扫描资源文件夹,用于自动嵌入文件或者 IDE 智能提示

<!-- more -->


条件编译
------

[条件编译 (Conditional Compilation)](http://haxe.org/manual/lf-condition-compilation.html).

### ifelse

可以使用 `#if #else #elseif #end` 来检测 Defines(即 `-D key[=value]` 定义的编译参数)

> 或者假如你使用了一个名为 heaps 的 haxelib, 那么编译器会自动定义 `-D heaps`

```haxe
#if flash
  trace("flash");
#else
  trace("other");
#end

// 检测 flash player 版本
#if flash11_4
  trace("flash player version >= 11.4"); // 如果目标为flash,且指定的编译版本大于等于 FP11.4
#end

// 条件和逻辑运算符检测, 注意: 需要使用“小括号”
#if(haxe_ver > 3.2)
  trace("haxe version > 3.2");
#end

#if (neko && debug)
  // 只有在当平台为neko并且为debug模式
#elseif (flash || php)
  // flash 或 php 平台
#end
```

假如定义了 `-D some-flag`, 那么在检测时应该把减号 "-" 替换成 "_", 因此应该使用 `#if some_flag` 来检测。

如果使用了"条件或逻辑运算符（例: `>, ==, &&, ||`）", 那么表达式需要使用小括号。例: `#if (haxe_ver >= 3.3)`

> 如果你的项目是 openfl 项目, 那么通常你应该修改 xml 配置文件来设置 Defines, 如: `<haxedef name="hello" value="world" />`

### require

同样可以把条件标识符放置在 `@:require` 之后，如果没有满足条件, 那么只可以访问空的类名, 其所有字段(包括static类型)都不可访问.

```haxe
@:require(haxe_ver>3.1)
@:require(nodejs, "require haxelib nodejs")
class Foo{
	public var value:String;
	public function new(val:String){
		value = val;
	}
}
// `@:require(Compiler Flag [,"custom error message" ])`
```


宏
------


首先 haxe 宏分为三种类型, 也就是说这三种宏它们运行在不同的阶段。

* 表达式宏，通常表现为在正常的方法（function）上添加了关键字 `macro`

  ```haxe
  macro static function line(){
    var pos = haxe.macro.Context.currentPos();
    return macro $v{pos};
  }
  ```

* 构建宏 `@:build, @:autoBuild, @:genericBuild` 都属于这个范畴。

  > `@:build, @:autoBuild`: 用于修改已经定义在代码中的类,
  >
  > 而 `@:genericBuild` 则是创建一个新的类型, 因此需要在宏构建里通过 `Context.defineType` 定义一个新类型
  > 并且返回这个新类型。

* 初使化宏. 主要是通过 编译参数 --macro 来执行, 运行顺序在解析 main 之前, 所以通常用来配置编译器行为


------


* haxe.macro 包下有很多工具类能更好地构建, 如: TypeTools, ExprTools

* 使用 Context.parseInlineString 用于解析字符串代码

  这个方法有一定的局限性, 例如: 不可以包含 `class` 这些

  ```haxe
  macro public static function tut_parse() {
  	var str = "测试";
  	var code:String = '
  		@:mergeBlock {
  			var map = new haxe.ds.StringMap();
  			map.set("note","${str}");
  			return map;
  		}';
  	return  haxe.macro.Context.parseInlineString(code,haxe.macro.Context.currentPos());
  }
  ```

### Reification Escaping

手工输入 AST 表达式非常繁琐，因此 haxe 添加了 macro 这个关键字用于 **自动将 “表达式” 转换成相应的 AST**, 例:

```haxe
var pos = haxe.macro.Context.currentPos();
macro 101;    // { expr: EConst(CInt(101)), pos: pos}
macro :Int    // TPath({name: "Int", pack: [], params: [] })
```

<http://haxe.org/manual/macro-reification-expression.html>

* `${} 或 $e{}: Expr -> Expr`

* `$a{} : Expr -> Array<Expr>` 用于把数量未确定的参数传递给函数, 示例见 Promhx 库的 Promise.when 或 JQueryHelper

  ```hx
  static macro function foo(args: Array<haxe.macro.Expr>){
      return macro trace($a{args});
  }
  ```

* `$b{} : Array<Expr> -> Expr` 构建**块表达式**

* `$i{} : String -> Expr` 注: 这里的 String 变量名字符串. 表示为: EConst(CIdent())

* `$p{} : Array<String> -> Expr` path. String 指的是变量名. 例: `macro $p{["Main","main"]}; => Main.main`

* `$v{} : Dynamic -> Expr` 这个经常会用到. e.g: `return macro $v{"hello world"}`

[最新, 使得泛型创建更容易](https://github.com/HaxeFoundation/haxe/commit/5411d122d03ed7c604c4afc559e9f0c8dbd1c8a4)

haxe 3.1+

* 字段名 {$name : 1}

* 函数名 function $name(){}

* `try/catch` try{e()}catch($name:Dynamic){}

```haxe
class Main {
	macro static function generateClass(funcName:String) {
		var c = macro class MyClass {
			public function new() { }
			public function $funcName() { //函数名
				trace({ $funcName : "was called" }); //字段名
			}
		}
		haxe.macro.Context.defineType(c); // 动态定义的类需要通过定义,外边才可以引用.
		return macro new MyClass();
	}
	public static function main() {
		var c = generateClass("myFunc");
		c.myFunc();
	}
}

// 一个返回 new SelfClass() 的示例:
static public function build(){
   var cplx = Context.toComplexType(TInst(Context.getLocalClass(), []));
   var path : Null<TypePath> = switch(cplx) {
       case TPath(t): t;
       default: throw "Trying to apply this macro to enum?";
   }
   fields.push({
       name : "fromString",
       access: [APublic, AStatic],
       kind: FFun({
           args: [{name:"str", type: macro : Null<String>}],
           ret : cplx,
           expr: macro {
               return new $path(str);
           }
       }),
       pos: Context.currentPos()
   });
}
```

### 宏构建

需要理解 AST,以前了解 haxe.macro 包中的所有类. [新参考](http://haxe.org/manual/macro-type-building.html) [参考](http://old.haxe.org/manual/macros/build)

build宏函数 与 普通的宏函数不一样的地方:

* 返回的类型不是 `Expr` ,而是 `Array<Field>`. (`haxe/macro/Expr.hx` 文件中定义了 `Field`)

* build 宏函数内部的 macro.Context **没有** getLocalMethid 和 getLocalVars.

* build 宏函数内部的 macro.Context **有** getBuildFields()

* 不是直接调用,而是将元标记 `@:build` 或 `@:autoBuild` 放在一个 `class` 或 `enum` 定义中.

[build 一个示例]({% post_url haxe/2014-05-13-tips-on-haxe %}#自定义元标记-metadata), 其实 haxelib heaps 库中 hxd 目录下有很多很好的宏构建示例


**在宏构建方法中, 使用 macro 关键字能省很多麻烦的事情**, 比如宏动态创建字段时: 注意 kind 字段

```haxe
// 创建一个 MIN 的静态常量值.
public static function buildMIN(){
	var fields = Context.getBuildFields();
	var pos = Context.currentPos();
	fields.push({
		name : "MIN",
		access : [APublic,AStatic,AInline],

		//下行的第一个参数也可以用 FVar(TPath({name:"Int" ,pack:[]})
		//kind : FVar(TPath({name:"StdTypes", pack:[], params:[], sub:"Int" }), {expr: EConst(CInt("200")), pos: pos }),
		//kind : FVar(Context.toComplexType(Context.getType("Int")), Context.makeExpr(200,pos))	// Context类有一些方法
		kind: FVar(macro :Int, macro 200),	// 使用 macro 让一切变得简单
		pos : pos
	});
	return fields;
}
```

```haxe
#if (haxe_ver >= 3.2)
macro : Void;
#else
Context.getType("Void");
#end
```

#### genericBuild

泛型构建. 主要是用理处理泛型, 比如你可以读取一个文本文件而构建一个相应的类(先定义,然后返回类型)

* 当泛形类使用 **Const**作参数时,例如:`class Some<Const>{}` [使用常量作为泛形参数](http://haxe.org/manual/macro-generic-build.html#const-type-parameter)

  这个特性被用于 SPOD 中的数据类型,比如限制字符串的长度： `typedef SString<Const> = String`;

和 `:build` 的区别:

* 返回类型为 `ComplexType`, 而不是 `Array<Field>`, 返回值将

  ```haxe
  // Main.hx
  class Main{
  	static pubic function main(){
  		var s:Some = "Hello world";
  		s.substr(1,5);	// haxe 会自动帮你导出 substr 方法是如何实现的, 是不是很神奇很复杂??但却不实用
  		// 因此 genericBuild 函数中你应该先构建一个类型通过 Context.defineType,然后返回它,这才是正确的做法.
  		// 或者 通过 defineModule 构建一个模块,最后返回 null 值. 这样的话 Some 相当于一个空类
  	}
  }


  // Some.hx
  @:genericBuild(Some.gen())
  class Some{
  	static function gen():ComplexType{
  		return macro :String;	// 把 Some 实例(instance)当成 String 类型
  	}
  }
  ```

### 成员宏方法

上边示例的都是都过 static 的方式调用 宏方法, 当宏方法为成员方法时, 第一个参数将由编译器自动填充为 `this`

* 限制: haxe 3.2 注意当宏方法为成员方法(非static)时,

* 限制: 不能在同一个相同文件中调用这个宏方法。 如: 在 Foo.hx 定义的成员宏方法，不可以在 Foo.hx 中调用.

* 在以链式的方法调用它时, 注意它能会返回 null 值,

  ```haxe

  class Main{
  	public static function main(){
  		var f = new Foo();
  		f.test();
  	}
  }

  // Foo.hx
  #if macro
  	import haxe.macro.Expr;
  	import haxe.macro.Context;
  	import haxe.PosInfos;
  	import sys.io.File;
  #end
  class Foo{
  	pubic function new(){}
  	// 你不能在 Foo.hx 中调用 test 方法
  	macro public function test(thiz){
  		var callerType	= Context.typeExpr(thiz);
  		return macro null;
  	}
  }
  ```

感觉没什么机会能用到这个特性, 感觉用 inline 似乎能做同样的事情.

### Compiler

haxe.macro.Compiler 的一些方法, 这个类的方法运行在编译时, 当编译参数 `--macro` 后调用方法时,默认为这个包下的方法.

例如: 'haxe --macro define('SomeFlag','Hello')', 记得字符串用 **单引号** 而不是 双引号.

[haxe 命令行编译参数]({% post_url haxe/2014-03-30-commands %}#haxe)

```haxe
// 就像 haxe 编译的参数 -cp, 将指定的路径添加类路径
addClassPath(path:String):Void;

//
addGlobalMetadata(pathFilter:String, meta:String, recursive:Bool = true, toTypes:Bool = true, toFields:Bool = false):Void

//
addMetadata(meta:String, className:String, field:String = null, isStatic:Bool = null):Void


// Adds a native library depending on the platform (eg : -swf-lib for Flash)
addNativeLib(name:String):Void


//　允许访问指定的包, 例如: 默认情况下当目标平台为 neko 时, 不允许访问 flash 包下的API., 参见 openfl 编译选项
allowPackage(v:String):Void

// 像 haxe 编译参数 -D
define(flag:String, value:String = null):Void

// Exclude a given class or a complete package from being generated
// 手动排除给定的包或类名在编译时, 由于编译参数 -dce 的关系, 事实上你不用调用这个方法
exclude(pack:String, rec:Bool = true):Void


// Exclude classes listed in an extern file (one per line) from being generated.
// 读取指定文件, 排除 外部类清单 每行一个
excludeFile(fileName:String):Void

// 得到 -D 定义的值.
getDefine(key:Dynamic):Dynamic

// 未知. 估计是用于 代码 编辑器
getDisplayPos():Null<{pos:Int, file:String}>

// 得到编译时输出的绝对全文件名, 例如: haxe -main Main -swf main.swf, 那么这个方法返回 D:\path\main.swf
getOutput():String

/**
 	这个方法形为类似于代码中的 import pack.*;
 @param rec		归递包含所有子项
 @param ignore	要忽略的类名数组, 包含路径在内的全名.
 @param classPaths pack　(自行查看最新的文档更新).
*/
include(pack:String, rec:Bool = true, ignore:Array<String> = null, classPaths:Array<String> = null)


includeFile(fileName:Dynamic):Dynamic;

/**
	重要: haxe 3.2 改动 https://github.com/HaxeFoundation/haxe/issues/4111
	- 最新的改动导致 这个命令似乎失去了作用, 但 @:keep 没变, 对于些文档构建请使用 include

	防止 包 或类 或字段 被 -dce 编译参数删除, 参见  命令行编译参数 的 @:keep 元标记

	这个标记经常被以 @:keep 的形式添加到 类或静态字段上

@param path			包,模块或 子类型
@param paths		包,模块或 子类型 数组, 就是 path 参数的数组形式,
@param recursive	如果为 true, 将归递包含 sub-packages 针对 paths
*/
keep(path:String = null, paths:Array<String> = null, recursive:Bool = true):Void

// 加载 flash 补丁文件
patchTypes(file:String):Void

// 移除指定字段
removeField(className:String, field:String, isStatic:Bool = null):Void

// 自定义 js 输出, e.g: --macro haxe.macro.ExampleJSGenerator.use()
setCustomJSGenerator(callb:JSGenApi -> Void):Void

// 设置字段类型
setFieldType(className:String, field:String, type:String, isStatic:Bool = null):Void

// 设置输出文件名, 绝对路径全名包括磁盘. 例如编译到 hello.swf, 那么 输出文件名为 X:\path\to\hello.swf
setOutput(fileOrDir:String):Void
```


### Context

haxe.macro.Context 上下文,就是调用这个类方法的环境, 也就是说如果在 Test.hx 代码的 第 6 行调用了一个自定义的宏方法例如: Um.some(), 那么这第 6 行就是 宏的上下文环境. Um.some 方法体内的 currentPos() 也只是返回第 6 行, getLocalModule 也只是返回 第 6 行处所在的 类模块.

```haxe
package;

class Test{
	public static function(){
		trace("Context");
		Um.some();
	}
}

class Um{
	macro static function some(){
		trace(haxe.Context.currentPos());		//输出在编译端: #pos(Test.hx:6: characters 2-7)
		trace(haxe.Context.getLocalModule());	//输出在编译端: Test
		return macro null;
	}
}
```

这个类的方法经常用于 宏方法, 宏构建中, 下列方法未注释的请参数 API 文档描述.

```haxe
// 添加资源文件, haxe.Resource 类能获得这个方法定义的资源文件, 通过 -resource file@name 在编译命令行定义
addResource(name:String, data:Bytes):Void

// 返回上下文的位置,
function currentPos():Position

// 定义新模块, 也就是像在一个 hx 文件中写几个类或定义. 通常来说 defineType 就够用了.
defineModule(modulePath:String, types:Array<TypeDefinition>, imports:Array<ImportExpr> = null, usings:Array<TypePath> = null):Void

// 定义一个类型 ,示例见: heaps 游戏引擎 hxd.res.FileTree.hx
defineType(t:TypeDefinition):Void

// 检测是否存在一个 -D 定义
function defined(s:String):Bool

// 检测 -D 定义的值, 如果仅定义标记,那么默认为 字符串 1,
definedValue(key:String):String

// 抛出编译错误, 并中断当前宏调用
error(msg:String, pos:Position):Dynamic

// 3.3 Dev版 https://github.com/HaxeFoundation/haxe/issues/2278
eval(e:Expr):Dynamic

// 抛出编译错误, 并中断当前编译
fatalError(msg:String, pos:Position):Dynamic

// Follows a type. See haxe.macro.TypeTools.follow for details.
follow(t:Type, once:Bool = null):Type

// 用于 宏构建 @:build 或 @:autoBuild 所在上下文
getBuildFields():Array<Field>

// 得到编译时类全部路径,包括调用的 haxelib 所在路径, -cp 包含的路径, 甚至包含调用了 haxe 标准库下的 std及各目标平台的 _std 目录路径
getClassPath():Array<String>

// Returns the constructor arguments that are used to construct the current @:genericBuild class, if available.
// Returns null if the current macro is not a build-macro which was called from constructing a @:genericBuild instance.
getConstructorArguments():Null<Array<Expr>>

// haxe 3.2+ 得到所有 -D 的定义
getDefines():Map<String, String>

//
getExpectedType():Null<Type>

// 得到上下文所在 类名
getLocalClass():Null<Ref<ClassType>>

// 3.3 Dev版, 仅获得数据, 修改获得的数据不会对编译器有任何影响
getLocalImports():Array<ImportExpr>

// 得到上下文所在 方法名
getLocalMethod():Null<String>

// 得到上下文所在 模块名(hx源码文件名,但不包含文件扩展名)
getLocalModule():String

//
getLocalTVars():Map<String, TVar>

// Returns the current type in/on which the macro was called.
// http://haxe.org/manual/macro-generic-build.html
getLocalType():Null<Type>

//
getLocalUsing():Array<Ref<ClassType>>

//
getLocalVars():Map<String, Type>

// 得到指定模块名(hx源码文件名,但不包含文件扩展名)所定义的类型数组
getModule(name:String):Array<Type>

// 得到上下文所在位置信息,
// Tips: 通过这个方法可以得到一个 上下文所在的文件路径, 在自定义库中加载资源很方便.
getPosInfos(p:Position):{min:Int, max:Int, file:String}

// 取得所有 -resource 定义的资源
getResources():Map<String, Bytes>

// 得到已经存在的指定类型, 如: getType("Int")
getType(name:String):Type

// Returns a syntax-level expression corresponding to typed expression t.
// This process may lose some information
getTypedExpr(t:TypedExpr):Expr

/**
Builds an expression from v, 自动解析 v 的值 构建相应的 Expr

This method generates AST nodes depending on the macro-runtime value of v. As such, only basic types and enums are supported and the behavior for other types is undefined

The provided Position pos is used for all generated inner AST nodes.
*/
makeExpr(v:Dynamic, pos:Position):Expr

// Builds a Position from inf.
makePosition(inf:{min:Int, max:Int, file:String}):Position

//
onAfterGenerate(callback:Void -> Void):Void

// 当准备生成输出代码时,你可以获得所有类型, 甚至可以将这些类型生成你想要的目标语言如果你有精力做这个的话.
onGenerate(callback:Array<Type> -> Void):Void

//配合 registerModuleReuseCall 一起使用
onMacroContextReused(callb:Void -> Bool):Void

//
onTypeNotFound(callback:String -> TypeDefinition):Void

// 解析字符串代码, 实际上经常用 parseInlineString 代替这个方法
parse(expr:String, pos:Position):Expr

// 解析字符串代码
parseInlineString(expr:String, pos:Position):Expr

// 注册模块依赖用于缓存编译, 如果你没有使用缓存编译, 将没有任何效果.
// 在 heaps 的 hxd.res 库中经常能见到这个方法示例. 如果 externFile 文件发生改变,那么所关联的 类(modulePath), 将会重刷新到缓存
registerModuleDependency(modulePath:String, externFile:String):Void

// Add a macro call to perform in case the module is reused by the compilation cache.
// you can add a specific macro action to be made in case a given cached module is reused in later compilations by using Context.registerModuleReuseCall
// please note that the macro call is a string that can only contain constant data (it is executed in a similar way as --macro command line parameter)
// `std/sys/db/RecordMacros.hx` 有个示例, 感觉就像是帮你写了一个 `--macro Cls.build()` 的编译参数， 但奇怪的要如何执行第一次宏调用了???
registerModuleReuseCall(modulePath:String, macroCall:String):Void

// 从 classPaths 是否存在指定文件名, 并返回 绝对路径全名. 参考 getClassPath 将会返回哪些类路径
// 对于 windows 平台会将 /path/to/file 这种 unix 斜线路径转成 windows 系统能识别的反斜线.
resolvePath(file:String):String

//
signature(v:Dynamic):String

// 根据指定类型创建复杂类型 , 参看 makeExpr
// toComplexType( getType("Int") ) 等于 `macro :Int` 等于 `TPath({name:"StdTypes", pack:[], params:[], sub:"Int" })`
// 那么简单类型就是 `macro Int` 返回的值 `src/Main.hx:34: { expr => EConst(CIdent(Int)), pos =>...}`
toComplexType(t:Type):Null<ComplexType>

// Types expression e and returns the corresponding TypedExpr.
typeExpr(e:Expr):TypedExpr

// Types expression e and returns its type.
typeof(e:Expr):Type

// Returns true if t1 and t2 unify, false otherwise
unify(t1:Type, t2:Type):Bool

// Displays a compilation warning msg at the given Position pos
warning(msg:String, pos:Position):Void
```


### 宏高级特性

[参考](http://old.haxe.org/manual/macros/advanced)

* 可变参数, 如果你希望使用可变参数,可以使用 `Array<Expr>` 作为最后一个参数

  ```haxe
  macro public static function J(exprs:Array<haxe.macro.Expr>) {
    return macro new js.jquery.JQuery($a{exprs});
  }
  ```

* 更可读

  > 大部分宏方法使用 Expr 类型参数并且返回的也是 Expr 类型,为了让代码更为可读, 你可以使用 `ExprOf<Type>` 来替代 `Expr`
  >
  > 如果你查看源码的话会发现其实 `typedef ExprOf<T> = Expr`


* 成员宏方法

* 宏 + using

* Macro-in-macro

* End-of-compilation generation

* 使用宏进行编译器配置

  > 编译时使用类似于 `--macro : call the given macro before typing anything else`
  >
  > 例:添加编译标记: --macro include('my.package')
  >
  > openfl 示例: `<haxeflag name="--macro keep('PlayState')" />`

* 基准测试 / 优化 (Benchmarking / Optimization)

<br />
