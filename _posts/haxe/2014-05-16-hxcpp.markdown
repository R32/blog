---

layout: post
title:  hxcpp
date:   2014-05-16 7:16:19
categories: haxe

---

这里主要记录一些和 hxcpp 相关的东西, 由于我没有找到 hxcpp 的相关文档, 因此不证内容的正确性.

需要安装 [haxelib hxcpp](https://github.com/HaxeFoundation/hxcpp)。　

### Hello World

```haxe
class Main{
	public function new(){
		trace("Hello World!");
	}
	public static function main(){
		new Main();
	}
}
```

hxcpp 会自动根据平台选择不同的 C++编译器. 任意平吧上编译命令为: `haxe -main Main -cpp cpp`

<!-- more -->


### 未整理

 * 实际上你可以在 neko 中快速开发及测试,因为 cpp 和 neko 的 API 基本一致,等到将要 release 时再以 hxcpp 编译

#### Cpp Magic

`__cpp__` 直接在 haxe 代码中嵌入 cpp 源码.　https://github.com/HaxeFoundation/haxe/pull/2875


```haxe
// __cpp__ 后边的 字符串不支持　字符串连接变量, 只是直接常量字符串
untyped __cpp__('printf("hello world!")');

// 使用下边方法传递变量到 __cpp__
inline private static function setInt(bytes:haxe.io.BytesData, addr:Int, x:Int){
	untyped __cpp__("*((int *) ({0}->GetBase() + {1})) = {2}",bytes,addr,x);
}
```

#### defines

内容有些长，而且没有说明.　http://haxe.org/manual/target-cpp-defines.html

#### metas

In order to [improve support for interacting](http://haxe.1354130.n2.nabble.com/hxcpp-native-access-td6968232.html) with CPP. 这些元标记大多是加在 class 上边的.


```bash
## 提取自 haxe --help-metas
#
@:abi					# Function ABI/calling convention

#
@:buildXml				# Specify xml data to be injected into Build.xml

@:cppFileCode			# Inject code into top of cpp file

@:cppInclude			# File to be included in generated cpp file

@:cppNamespaceCode		# ...

@:decl					#

@:depend 				# Add a dependency in the build.xml file.

@:functionCode			# Inject code into top of function - eg, whole implementation.

@:functionTailCode 		# Inject code into end of function - eg, close functionCode, or continue processing.


# 注入 cpp 代码到 头文件(.h) Class 的内部 - 用于声明　成员变量或成员方法 例如: @:headerClassCode("int a,b")
@:headerClassCode		# Code to be injected into the generated class, in the header

# 注入 cpp 代码到 头文件(.h) Class 的外部 - 用于 添加 头文件引用或 宏定义 例如: @:headerCode("#include <stdio.h>")
@:headerCode()			# Code to be injected into the generated header file

# 在 头文件(.h) 中 注入 例如: @headerInclude("stdio.h")  - 个人注: 好像没什么用,因为只能添加一个头文件
@:headerInclude(String)	# File to be included in generated header file

@:headerNamespaceCode   # ..

# @:include("ClassName") - Generate "#include ..." to .h/.cpp where the class is being imported.
@:include				# 

@:nativeProperty 		# Use native properties which will execute even with dynamic usage

# 编译的cpp代码中不包含有类似于 HX_STACK_LINE...这些调试用的代码, 只用于字段或方法(但是好像无法作用于构造函数),
@:noStack				# 

# cpp 源文件名 用于 external class - 路径以当前 hx 文件所在为当前目录,参考 hxcpp/test/native 目录
@:sourceFile("path/to/file.cpp")			# Source code filename for external class

@:structAccess			# Marks an extern class as using struct access('.') not pointer('->')

@:unreflective			#

@:void					# Use Cpp native 'void' return type (cpp only)
```

#### 调试

http://gamehaxe.com/2012/09/14/hxcpp-built-in-debugging/

### 混合编程

发现一些库并没有使用 CFFI 那种方式,如 hxsdl, 它是混合了 C++ 在 haxe 代码中.　这样的代码比 cffi 性能更好.因为尽量避免了 haxe 变量和 cpp 变量的数据交换.

参看 hxsdl 及 hxcpp 中的源码可以发现 混合编程即使用了 metas 来嵌入一些 cpp 源码, 只是有些是通过　宏自动实现的.多参考 `hxcpp/test` 下的示例


#### 变量转换

haxe 变量到 cpp 变量　之间的转换, 其它没有记录的类型如 Array String 都是属于 HXArray HXString 这些类

可以参考 `hxcpp/include` 下的一些头文件查看一些定义:

```cpp
// hxcpp/include/hxcpp.h 部分代码

// Basic mapping from haxe -> c++
typedef int Int;
typedef bool Bool;

#ifdef HXCPP_FLOAT32
typedef float Float;
#else
typedef double Float;
#endif


// Extended mapping - cpp namespace		
namespace cpp{
   typedef signed char Int8;
   typedef unsigned char UInt8;
   typedef char Char;
   typedef signed short Int16;
   typedef unsigned short UInt16;
   typedef signed int Int32;
   typedef unsigned int UInt32;
   #ifdef _WIN32
   typedef __int64 Int64;
   typedef unsigned __int64 UInt64;
   // TODO - EMSCRIPTEN?
   #else
   typedef int64_t Int64;
   typedef uint64_t UInt64;
   #endif
   typedef float Float32;
   typedef double Float64;
};
```

### CFFI

将外部的 C/C++ 库编译成 lib.ndll 用于在　haxe 代码中调用. hxcpp 源码的 test 中有一个 cffi 的示例.

一个工具能自动写一些模板 https://github.com/player-03/ExtensionBoilerplate

### 编译外部库

直接将外部库编译成 静态链接库, 参考 [nme-dev](https://github.com/haxenme/nme-dev) 的 Readme

一个基于 hxcpp 的项目的　文件夹组织

```bash
include/			# C/C++ 源码所依赖的头文件,
lib/				# 编译 C/C++ 时的中间文件,
project/			# C/C++ 源码目录
tools/				# 一些命令行工具类源码, 如果通常这个文件夹内会包含  run.n, build.n 的源码等等
ndll/ 				# 最终结果目录, 不同平台将分开在各自的目录
```

编译, 一般通过 haxelib run hxcpp Build.xml 或者 neko build.n

 * Build.xml 目前我没找到自动生成的方法,只能照着别的库写

 * build.n 是通过编译了 hxcpp/Builder.hx 或它的继承类

```bash
cd project
haxelib run hxcpp Build.xml								# 如windows系统 则在 ndll/windows/ 生成 .ndll 文件	
haxelib run hxcpp Build.xml -Dandroid					# 在ndll/android/下 生成 .so 文件
haxelib run hxcpp Build.xml -Dandroid -DHXCPP_ARMV7		# armv7

# mac 系统
haxelib run hxcpp Build.xml -Diphoneos -DHXCPP_ARMV7	#需要 Xcode 环境
```



#### openfl 的示例

如果你使用 openfl 项目,那么运行 `lime create extension myext` 将创建一个 CFFI 样板文件

```
dependencies/		# android java 原生扩展, 相对于这篇文章主题可以不用关心它
project/
Myext.hx			# openfl 引用示例, - 文档类
haxelib.json		# 如果要将这个库上传至 haxelib 
include.xml			# openfl 引用示例, - 配置
ndll/				
```


### 源码分析

在 toolchain 目录下的 xml 文件可以找到这些平台支持细节

```
windows:		MSVC 或 MingW
linux:			GCC
mac:			GCC;需要xcode环境
ios:			GCC;需要xcode环境
android:		NDK
emscripten:			
blackberry:
tizen:
webos:			PalmPDK
```

解析 haxelib/run.n 源码:

 > 通过 `neko.vm.Loader.local().loadModule("./hxcpp.n")` 加载了 `hxcpp/tools/hxcpp/BuildTool.hx`

<br />


旧的内容
------

从这里开始往下, 是以前旧的内容, 随时将会被删除
 
**不使用 openfl** 编译为 cpp 或 neko

 > 例如你想写一个 命令行程序, 

 > 即使是命令行程序也是能引用 ndll lime,虽然没有界面. lime-tools 就是这样一个程序.
 
```haxe
#if neko
import neko.Lib;
#else
import cpp.Lib;
#end
class Test1 {
	public static function main(){
		Sys.println(myext_sample_method(16));
	}
	static var myext_sample_method = Lib.load ("myext", "myext_sample_method", 1);
}
```

```bash
#编译到 hbin 目录中去
haxe -cpp hbin -main Test1
	
#复制 ndll文件到 hbin下 dos
copy ndll\windows\ext.ndll hbin\
```
 

**使用 openfl** 编译到平台 

 * 需要将 myext 添加到 haxelib 本地库.否则oepnfl在分析 ndll 路径时将出错.
 
	 ```bash
	 #小数点为当前目录
	 haxelib dev myext .
	 ``` 
 
 * 修改 include.xml 将与 android java 的原生扩展相关代码注释掉

	> 因为那些从实现原理上来说属于 NDK JNI.

	```xml
	<?xml version="1.0" encoding="utf-8"?>
	 <!-- inclucde.xml -->
	 <project>
		<ndll name="myext" />
		<!-- dependency name="myext" path="dependencies/android" if="android" / -->
		<!-- android extension="org.haxe.extension.Myext" / -->
	 </project>
	```

 * `project.xml` 和 `Main.hx`
 
	 ```xml
	 <?xml version="1.0" encoding="utf-8"?>
	 <!-- project.xml -->
	 <project>
	  <meta title="TestApp" package="me.lab.test" version="1.0.0" company="R.U.N" />
	  <app main="Main" path="bin" file="TestApp" />
	  <source path="." />
	  <haxelib name="openfl" />
	  <haxelib name="myext" />
	 </project>
	 ```
 
	 ```haxe
	 // Main.hx
	 #if neko
	 import neko.Lib;
	 #else
	 import cpp.Lib;
	 #end
	 class Main {	
		public static function main(){	
			var t = new flash.text.TextField();
			t.text = Std.string(myext_sample_method(16));
			flash.Lib.current.addChild(t);
		}
		static var myext_sample_method = Lib.load ("myext", "myext_sample_method", 1);
	 }
	 ```

 * 编译

	 ```bash
	 lime test project.xml windows
	 lime test project.xml neko
	 lime test project.xml android
	 ```
