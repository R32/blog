---
layout: post
title:  HXSL(着色器)
date:   2014-11-16 13:16:18
categories: haxelib
---


AGAL
-------

很多帮助说明可以在 参考AS3 API 手册的相关 class.  [什么是AGAL](http://www.adobe.com/cn/devnet/flashplayer/articles/what-is-agal.html) - TODO: 这个链接似乎已经不存在了.

<!-- more -->

资源限制:

```
#资源                允许的数量        总内存
Vertex buffers       4096             256 MB
Index buffers        4096             128 MB
Programs             4096              16 MB
textures             4096             128 MB
Cube textures        4096             256 MB
```

AGAL 限制：每个程序 200 个 opcode。

### AGAL着色器

上载到 Context3D 的一对渲染程序, 会在每次调用 Context3D.drawTriangles 时运行。vertexProgram 将要绘制的三角形列表中的每个顶点执行一次。fragmentProgram 则将三角形表面的每个像素执行一次

* **vertexProgram** 将操作 VertexBuffer3D 中定义的数据，负责将顶点投影到剪辑空间，并将任何所需的顶点数据（例如颜色）传递到 fragmentProgram

  > 将接收来自两个源的输入：顶点缓冲区和常量寄存器。使用 Context3D setVertexBufferAt() 方法指定具体顶点"属性寄存器"将要使用的顶点数据。您最多可以为顶点属性定义 8 个寄存器。顶点属性值读取自三角形列表中每个顶点的顶点缓冲区，并放置在属性寄存器中。
  >
  >使用 Context3D setProgramConstantsFromMatrix() 或 setProgramConstantsFromVector() 方法指定"常量寄存器"。常量寄存器为三角形列表中的每个顶点保留相同的值。（您只能在 drawTriangles() 调用之间修改常量值。）
  >
  > 负责将三角形顶点投影到剪辑空间（x 和 y 轴上 ±1 之间和 z 轴上 0-1 之间的规范可视区域），并将转换后的坐标放置到输出寄存器中。
  >
  >（通常，将通过一组常量寄存器为着色器提供适当的投影矩阵。）vertexProgram 还必须将 fragmentProgram 所需的任何顶点属性或计算值复制到一组名为渐变 寄存器的特殊变量中。在运行片段程序时，将根据当前片段与三角形每个顶点的距离线性插入渐变寄存器提供的值。

* **fragmentProgram** 将操作 vertexProgram 传递给它的属性，并为三角形的每个栅格化片段生成颜色，最终形成像素颜色。

  > 接收来自渐变(矩阵)寄存器和一组独立常量寄存器的值（使用 setProgramConstantsFromMatrix() 或 setProgramConstantsFromVector() 设置）。
  >
  > 也可以从使用取样寄存器上载到渲染上下文的纹理读取纹理数据。使用 Context3D setTextureAt() 方法指定具体取样器寄存器要访问的纹理。fragmentProgram 负责将其输出寄存器设置为颜色值。
  >
  > 请注意，fragmentProgram 在 3D 编程文献中具有多个名称，如: 片段着色器 or 像素着色器

### AGAL寄存器

语法: `<opcode> <destination>, <source 1>, <source 2 or sampler>`

每个寄存器为128位宽，这意味着它包含4个浮点值,每个值称为寄存器的一个成分。

寄存器组件可通过坐标存取器（xyzw）或通过颜色存取器（rgba）存取,


* **属性:**  顶点着色器输入, 使用 Context3D.setVertexBufferAt() 指定的顶点缓冲区

  - 仅用于 vertexProgram **`va<0~7>`**

* **常量:** 处理 AS3 传递到着色器参数. 由 Context3D::setProgramConstants() 设置

  - **`vc<0~127>`** 用于 vertexProgram

  - **`fc<0~27>`** 用于 fragmentProgram

* **临时:** 用于计算的临时寄存器, 无法从程序外部访问

  - **`vt<0~7>`** 用于 vertexProgram

  - **`ft<0~7>`** 用于 fragmentProgram

* **输出:** 着色器输出,在 vertexProgram 中，输出为剪辑空间位置；在 fragmentProgram 中，输出为颜色

  - **`op`** 用于 vertexProgram

  - **`oc`** 用于 fragmentProgram

* **渐变:** 用于将数据从 vertexProgram 传递到 fragmentProgram。传递的数据由 GPU 恰当地插入，使 fragmentProgram 能够收到被处理的像素的正确值

  - **`v<0~7>`**

* **采样:** 像素着色器输入, 读取自使用 Context3D.setTextureAt() 指定的纹理
  - **`fs<0~7>`** 仅用于 fragmentProgram

  ```
  # 语法为 fs<n> <flags>, 其中 <flags> 定义为:

  纹理维度: 2d, cube

  mip映射: nomip(mipnone), mipnearest, miplinear

  纹理过滤: nearest, linear

  纹理重复: repeat, wrap, clamp

  # 例如，一个没有MIP映射和现象过滤的标准2D纹理可以使用以下代码采样到临时寄存器 ft1 中：
  tex ft1, v0, fs0 <2d,linear,nomip>

  # 在上面的示例中，可变寄存器 v0 持有插入的纹理UV。
  ```


<br />

flash-hxsl
-------

hxsl 主要适用于 flash 的 AGAL, http://old.haxe.org/manual/hxsl, 应该多参考 hxsl 库的示例

```haxe
class Shader extends hxsl.Shader {

	static var SRC = {
		var input : {
			pos : Float3,
		};
		var color : Float3;
		function vertex( mpos : M44, mproj : M44 ) {
			out = input.pos.xyzw * mpos * mproj;
			color = input.pos;
		}
		function fragment() {
			out = color.xyzw;
		}
	};

}
```

分析 SRC 的内容为:

* 一个 input 变量, 对应于 VertexBuffer 中的一组数据

  > 如 VertexBuffer 除了坐标还包含颜色或uv数据, 那么 input 的数据类型应该定义相应的字段,如:

  ```
  var input : {
	  pos : Float3,
	  norm : Float3,
	  uv : Float2,
  };
  ```

* 0个或多个变量将由vertex shader写入插值, 让 fragment shader 读取（示例中的`var color`）

  > 在 vertex shader方法中给这些变量赋值, 在 fragment shader 中读取它们
  >
  > 例如: 你可能想要把 input 中的值传递给 fragment shader, 则可以在 vertex shader 方法中赋值

* 1个 vertex shader方法及其参数, 这个方法内可以直接访问 input 中的值

* 1个 fragment shader方法及其参数

shader 方法的参数可在外部赋值, 如 `shader.mpos = xxx, shader.texture = xxx`,

> fragment() 只能似乎只能访问 texture 类型的参数, 其它的坐标, 颜色需要通过 vertex() 间接获得

这二个 shader 方法都使用 `out` 作为输出， out 的类型为 Float4

变量类型定义:

* Float: 单个32位浮点数
* Float2, Float3, Float4: 2,3,4 个浮点数
* Matrix \| M44: 4x4矩阵 相应的矩阵
* M33, M43, M34:
* Texture: 2D纹理
* CubeTexture: 立方体纹理
* Int \| Color: 32位整数,　转化到 Float4 每个浮点数为 0.0~1.0

变量类型补充:

```
class MyShader extends hxsl.Shader {
    static var SRC = {
        var input : { pos : Float3, uv : Float2 };
        var tuv : Float2;
        function vertex( mpos : Matrix, mproj : Matrix ) {
            out = ((mpos == null) ? input.pos.xyzw : input.pos.xyzw * mpos) * mproj;
            tuv = input.uv;
        }
        function fragment( tex : Texture ) {
            out = tex.get(tuv);
        }
    };
}
```

* input 上边已经描述
* const 常量数据, 在 shader 中不会发生任何改变(例如上边的 mproj)
* param 一个可选的常量, (如上述中的 mpos)
* var 可用于 shader 内部定义变量
* texture 纹理(如: tex)
* tmp: 一个临时变量, 用于 shader 内部

<br />


heaps-hxsl
-------

heaps 游戏框架所使用的着色器, 可在相关的 wiki 上找到资料。

```haxe
class MyShader extends hxsl.Shader {
    static var SRC = {
        @input var input : { position : Vec3, normal : Vec3 };
        var output : { position : Vec4, normal : Vec3, color : Vec4 };
        var transformedNormal : Vec3;
        @param var materialColor : Vec4;
        @param var transformMatrix : Mat4;
        function vertex() {
            output.position = vec4(input.position,1.) * transformMatrix;
            transformedNormal = normalize(input.normal * mat3(transformMatrix));
        }
        function fragment() {
            output.color = materialColor;
            output.normal = transformedNormal;
        }
    };
}
```

通过上边的源码可以分析出:

1. 继承（extends） hxsl.Shader

2. 类中需要有一个名为 "SRC" 的 `static var`

### metas

不保证内容的正确性.

* `@local`:

* `@global`: 用于在多个 shader 之中共用。

* `@var`: 标记将要在"顶点着色器"中写入, 然后在"像素着色器"读取的变量(可选, hxsl 将会自动推导)。类似于 GLSL 中的 varying 类型

* `@param`: 在"着色器"中是只读的。 类似于 GLSL 中的 uniform

  > 这个变量值可以为 null(空), 而 @const 则必须提供

* `@const`: 如果参数发生改变则将被编译成不同的 shader。

* `@input`:

* `@function`:

* `@range(min, max)`: 限定参数数值的大小, Float

* `@private`:

* `@nullable`:

* `@perObject`:

* `@shared`:

* `@lowp`:

* `@mediump`:

* `@highp`:

* `@ignore`:

* 无标记的变量: 为 `pipeline variables`


带有 `:` 的元数据

* `@:import`: 导入另一个 hxsl.Shader

  ```haxe
  class TextDeform extends hxsl.Shader {
  	static var SRC = {
  		@:import h3d.shader.Base2d;
  		function vertex() {
  			spritePosition.y += sin(spritePosition.x * 0.5 + time * 30);
  		}
  	}
  }
  ```

* `@:extends`:


样例分析:

```haxe
class ScreenShader extends hxsl.Shader {
	static var SRC = {
		@input var input : {
			position : Vec2,
			uv : Vec2,
		};
		var output : {
			position : Vec4,
			color : Vec4,
		};
		function vertex() {
			output.position = vec4(input.position, 0, 1);
		}
	};
}
```

* 一个名为 output 的不带任何 meta 的变量作为输出, 通常应该带有 position 和 color 这二个字段.

  > 但一些 h3d/shader 类并未指定输出??? TODO:

* 相对于 flash-hxsl, 输入现在需要添加 `@input`
* 没有添加 meta 标记的将可以在 shader 方法内访问
* shader方法(名字分别为vertex和fragment) 似乎不再有参数了, 而是在 __init__ 方法内处理.

  - 分别有 `__init__, __init__vertex, __init__fragment` 这三个方法， 都属于 Ast.hx 下 FunctionKind.Init;
  - 而其它方法则都定义为 FunctionKind.Helper

* 一些方法如: vec4,sin,cos 可以参考 AgalOut.hx 中的 global 方法

简单示例:

```haxe
class TextDeform extends hxsl.Shader {
	static var SRC = {
		@:import h3d.shader.Base2d;
		function vertex() {
			spritePosition.y += sin(spritePosition.x * 0.5 + time * 30);
		}
	}
}
```

> TODO: 为什么不直接 `extends Base2d`, 而是采用 `@:import` 的方式？

<br />
