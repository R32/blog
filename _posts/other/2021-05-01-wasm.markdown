---

layout: post
title:  编译 c 到 wasm
date:   2021-05-01 09:27:10
categories: other

---

编译 c 代码到 wasm, 不使用 emscripten sdk.

<!-- more -->

### 参考

<https://surma.dev/things/c-to-webassembly/>

[wasm 指令集] 显示了 wasm 所能执行的操作(但似乎并不完整)

[clang Basic Builtins.def]

[clang Basic TokenKinds.def]

[BuiltinsWebAssembly.def]

一些需要用到的工具库, 使用 7zip 打开安装包或压缩档进行提取.

* `clang.exe` : 编译器

* `wasm-ld.exe` : 链接器, 提取自 [LLVM] 用于链接生成 wasm 或者打包成 .bc 库

  如果要归档则可以提取出 `llvm-ar.exe`

* `wasm-opt.exe` : 优化器, 提取自 [WebAssembly/binaryen] 用于 wasm 文件

* ~~`wasm2wat.exe`~~ : `wasm-opt.exe --print x.wasm` 一样能查看

我用的是 cygwin, 主要是因为要使用 Makefile 来辅助编译,
只是这些 exe 工具只接受 windows 路径, 传递路径时需要转换

> cygwin 提供了 cygpath 命令可以将路径相互转换


### wasm 内存模型

可以使用 `-z stack-size=<bytes>` 指定 stack 的大小

而 `--initial-memory=<bytes>` 指定的是整个内存的大小.

例如在 Makefile 中, `-z stack-size=$$((1024*64*10))` 将指定 640K 大小的 stack.

可以使用 `--stack-first` 将 stack 移到第一个区块, 这样能更好地监测到堆栈溢出.

```c
// |__memory_base
// |    |__global_base
// |    |          |__data_end     |__heap_base
// --------------------------------------------------
// | 空 |          |               |                |
// | 白 |  数据区  |    Stack <--- | ---> heap 区   |
// | 处 |          |               |                |
// --------------------------------------------------
// wasm 有内置几个变量, 可以使用 & 的形式访问, 如
// extern int __data_end;
// extern int __heap_base;
printf("data end: %d, heap base: %d, stack size: %d\n",
	&__data_end, &__heap_base, &__heap_base - &__data_end
);

// 当使用 --export-all --allow-undefined 链接时, js 端看到这几个内置变量, 如下:
__global_base : Global  // 数据段的起始点(我猜的), 这个值一般是 1024
__data_end    : Global  // 数据段的结束点, 即 stack 的最顶端
__heap_base   : Global  // 堆的起始点
__memory_base : Global  // 这个值一直是 0, 似乎表示的是整个内存的起始点?
__table_base  : Global  // 未知.
__dso_handle  : Global  // 出现在 emscripten_tls_init.h 中, 似乎与多线程有关

__wasm_call_ctors : fn  // 未知, 这个函数也许是 wasm 用于做某些初使化,
```

如果要实现 malloc/free, 可以先拿到 heap_base 的值, 那么

1. 如何在 c 端直接获得整个内存的大小?

  `__builtin_wasm_memory_size`

2. c 能直接调用 js 的 .grow() 函数吗? (不使用 EM_ASM 宏)

  `__builtin_wasm_memory_grow`


指令集里有个 memory.copy, 但是却没有相关的 c 语言宏,

```c
// 虽然有下边这个, 但感觉就是 clang 语言内置的, 因为最后一个必须要是常量
__builtin_memcpy_inline(dst, src, const int);
```

### 交互

wasm 默认使用 **env** 字段用于传递 js 数据到 c,

```c
#define EM_IMPORT(NAME) __attribute__((import_module("env"), import_name(#NAME)))
// 如果没有 import_module, 则默认为 "env"
// 这个宏说明了我们可以自定义 module name.
```

当你使用 `--import-memory` 时, 需要将 js 生成的 Memory 传递给 env.memory.

```js
var mem = new Memory({initial: 10}); // 64K * 10
var lib = new Instance(mod, {
	env : {
		memory : mem,

		// 传递 js 函数 给 c, 在 c 端则: EM_IMPORT(random) double random();
		random : Math.random,
	}
});
```

还有一个用于导出 c 函数到 js 的宏为:

```c
#define EM_EXPORT(name) __attribute__((used, export_name(#name)))

// e.g:
EM_EXPORT(square) int arbitrary_name(int n) {
	return n * n;
}
```

#### 数据类型转换:

wasm 只接受 i32, i64, f32, f64 这几个类型.

当从 c 传递或返回指针给 js 时, 其值将为 Memory 的偏移值,
(和以前的 flash alchemy 一样).

因此可推导出, 当你传递字符串到 c 时, 由于 js 字符串并没有位于 js.Memory 内,
因此你需要先把 js string 自己复制到 Memory 上, 再将偏移值传递进去.

其它复杂的数据同上. 这需要一个 malloc/free 来获得可用的偏移值

使用上边这些可以编译纯 c 代码到 wasm, 但是由于没有标准库,
因此除了一些简单的运算, 你什么也做不了, 因此你需要一个自己编译 c/c++ 标准库
否则你将无法编译现存的任何 c 语言写的库.

### 问题

1. 多个 wasm 他们之间如何共享内存了?
  似乎只能通过 js 间接地从 a 模块复制到 b 模块.

2. c 如何访问 js 传递过来的 Global 类型数据?
  ```wat
  ; 这是 wat 的源码, 它定义了要从 js.global 导入
  ; 但是 c 要如何做了? EM_IMPORT 只能用在函数上.
  ; 或者 c 根本就没有相关的定义.
  (module
   (global $g (import "js" "global") (mut i32))
   (func (export "getGlobal") (result i32)
        (global.get $g))
   (func (export "incGlobal")
        (global.set $g
            (i32.add (global.get $g) (i32.const 1))))
  )
  ```

[emscripten]:https://github.com/emscripten-core/emscripten
[WebAssembly/binaryen]:https://github.com/WebAssembly/binaryen
[WebAssembly/wabt]:https://github.com/WebAssembly/wabt
[LLVM]:https://releases.llvm.org/download.html
[LLVM __attribute__]:https://clang.llvm.org/docs/AttributeReference.html
[wasm 指令集]:https://webassembly.github.io/spec/core/appendix/index-instructions.html
[clang Basic Builtins.def]:https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/Builtins.def
[BuiltinsWebAssembly.def]:https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/BuiltinsWebAssembly.def
[clang Basic TokenKinds.def]:https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/TokenKinds.def